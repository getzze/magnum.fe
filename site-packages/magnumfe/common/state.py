# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-07-17

from __future__ import absolute_import 

import types
import uuid
import collections
import numpy as np
from inspect import isfunction

from dolfin import MeshFunction, Measure, FunctionSpace, VectorFunctionSpace, \
    Expression, interpolate, Constant, FunctionSpaceBase, assemble, \
    Function, interpolate, GenericFunction, inner, sqrt, TestFunction, dP, \
    TrialFunction, conditional, eq, dx, action, as_backend_type

from . import Material, WrappedMesh, Cache, Timer
from magnumfe.common.composite_material import CompositeMaterial

__all__ = ["State", "MaskedState", "AttributeCycleDependency"]

class AttributeCycleDependency(Exception): pass

def _update_uuid(self):
  self.uuid = uuid.uuid4()

def _crop(self, domain = "all"):
  value = self._state.interpolate(self)
  mesh  = self._state.wrapped_mesh_for(domain)
  return mesh.cut(value)

def _average(self, domain = "all"):
  volume = self._state.volume(domain)
  dx     = self._state.dx(domain)
  value  = self._state.interpolate(self)

  if value.rank() == 0:
    return assemble(value * dx) / volume
  elif value.rank() == 1:
    return tuple(map(lambda i: assemble(value[i] * dx) / volume, range(value.value_size())))
  else:
    raise Exception("Rank > 1 not supported")

def _normalize(self, graceful = True):
  if not isinstance(self, Function):
    raise Exception("Cannot normalize '%s'." % type(self))
  f = self.copy(True)
  v = TestFunction(f.function_space())

  # if graceful = True: (0,0,0) -> (1,0,0)
  #              False: (0,0,0) -> (0,0,0)
  fx = 1.0 if graceful else 0.0

  expr = conditional(eq(inner(f, f), 0.0), \
    Constant((fx, 0.0, 0.0)),           \
    f / sqrt(inner(f, f)))

  result = Function(f.function_space())
  assemble(inner(v, expr) * dP, result.vector())
  setattr(self._state, self.name(), result)

class State(object):
  def __init__(self, mesh, celldomains = {'magnetic': 1, 'conducting': 1}, facetdomains = {'outermagnet': 1}, material = None, scale = 1.0, t = 0.0, **kwargs):
    """
    This class holds the complete state of the simulation and provides some
    convenience wrappers for the handling of multiple domains. Furthermore
    it provides an interface for attribute handling and caching.

    *Domain/Material Examples*
      .. code-block:: python

        state = State(mesh,
          celldomains = {'magnetic': (1,3), 'conducting': 2, 'iron': 1, 'cobalt': 3}
          m = Expression(...)
        )

        # Set materials for different regions
        state.material['iron']       = Material(...)
        state.material['cobalt']     = Material(...)
        state.material['conducting'] = Material(...)

        # Use integration measures with named domains
        assemble(Constant(1.0) * state.dx('all'))       # All named domains
        assemble(Constant(1.0) * state.dx('magnetic'))  # Magnetic region
        assemble(Constant(1.0) * state.dx('!magnetic')) # Nonmagnetic region
        assemble(Constant(1.0) * state.dx(1))           # Region by ID

        # Compute average of magnetization m
        state.m.average()       # Over whole space
        state.m.average('iron') # Over iron region

        # Crop magnetization to subdomain and save as PVD
        f = File("m_iron.pvd")
        f << state.m.crop('iron')

        # Normalize the magnetization
        state.m.normalize()

    *Attribute Examples*
      .. code-block:: python

        # initialize state with constant magnetization. m is automatically
        # interpolated on a suitable discrete function space.
        state = State(mesh,
          m = Constant((1.0, 0.0, 0.0)),
        )

        # define a current as function of the time
        state.j = lambda state: Constant((state.t * 1e12, 0.0, 0.0))

        # define some functional depending on m
        state.E = lambda state: (assemble(inner(state.m, state.m)*state.dx()), "m")

        # dependencies can be arbirtrarily nested
        state.E_times_2 = lambda state: (2*state.E, "E")

        # all values are cached according to their dependencies
        state.E_times_2  # triggers computation of E_times_2
        state.E_times_2  # taken from cache, no computation

        state.m = Constant((0.0, 1.0, 0.0))

        state.E_times_2  # triggers computation of E_times_2

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        The mesh including all subdomains as :class:`dolfin.MeshDomains`
      celldomains (:class:`dict`)
        naming of the cell subdomains, at least the subdomains 'magnetic' and 'conducting' should be defined.
      facetdomains (:class:`dict`)
        naming of the facet subdomains
      material (:class:`Material`)
        the material of the sample. If material differs from subdomain to subdomain, use material setters instead.
      scale (:class:`float`)
        the spatial scaling of the mesh. Use 1e-9 if you use nanometers as length measure.
      t (:class:`float`)
        the time
      **kwargs (:class:`dict`)
        add any state variables like magnetization (m) or spin diffusion (s).
        Expressions are automatically interpolated on the corresponding discrete spaces.
        
    """

    self._uuid  = uuid.uuid4()
    self.mesh  = mesh
    self.scale = scale
    self.t = t
    self.set_celldomains(celldomains)
    self.set_facetdomains(facetdomains)

    # TODO add args to set domains via mesh functions directly
    self.cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
    self.facet_domains = MeshFunction('size_t', mesh, 2, mesh.domains())

    self._dx = Measure('dx', mesh)[self.cell_domains]
    self._ds = Measure('ds', mesh)[self.facet_domains]
    self._dS = Measure('dS', mesh)[self.facet_domains]
    self._dP = {}

    self._VS = FunctionSpace(self.mesh, 'CG', 1)          # TODO lazy initialize
    self._VV = VectorFunctionSpace(self.mesh, 'CG', 1, 3) # TODO lazy initialize

    self.material = material

    self._wrapped_meshes  = {}
    self._volumes         = {}
    self._func_attributes = {}
    self._M_inv_diag      = {}

    for key, value in kwargs.iteritems():
      setattr(self, key, value)

  def _decorate_attr(self, name, value):
    if isinstance(value, GenericFunction):
      value._state      = self
      value.update_uuid = types.MethodType(_update_uuid, value)
      value.crop        = types.MethodType(_crop, value)
      value.average     = types.MethodType(_average, value)
      value.normalize   = types.MethodType(_normalize, value)
      value.rename(name, value.label())
      value.update_uuid()
    return value

  def __setattr__(self, name, value):
    # handle lambda attributes
    if isfunction(value):
      self._func_attributes[name] = Cache(
          func  = value,
          uuid  = None,
          value = None,
          keys  = None,
          in_process = False
      )
      return

    if isinstance(value, GenericFunction):
      # always interpolate
      value = self.interpolate(value)

      # use assign if object exists
      if hasattr(self, name):
        attr = getattr(self, name)
        attr.assign(value)
        attr.update_uuid()
        return

      # decorate if object does not exist
      else:
        self._decorate_attr(name, value)

    super(State, self).__setattr__(name, value)

  def __getattr__(self, name):
    # handle lambda attributes
    if self._func_attributes.has_key(name):
      attr = self._func_attributes[name]

      # return uncached attribute
      if attr.keys == (): return attr.func(self)

      # check cycle dependency
      if attr.in_process:
        raise AttributeCycleDependency("Attribute dependency cycle detected.")

      # check cache hit
      if attr.keys is not None:
        uuid = self.uuid(*attr.keys)
        if uuid == attr.uuid: return attr.value

      # update cache
      attr.in_process = True
      value = attr.func(self)
      attr.in_process = False

      # set default hash keys
      if not isinstance(value, tuple):
        # primitives default to their value
        if isinstance(value, (int, float, str)):
          value = (value,)
        # others default to the time
        else:
          value = (value, "t")

      # XXX this seems to create a memory leak
      if isinstance(attr.value, Function):
        attr.value.assign(value[0])
        attr.value.update_uuid()
      else:
        attr.value = self._decorate_attr(name, value[0])

      attr.keys  = value[1:]
      if attr.keys != ():
        attr.uuid = self.uuid(*attr.keys)

      return attr.value

    raise AttributeError("'State' object has no attribute '%s'" % name)

  def uuid(self, *names):
    """
    Returns a uuid for a given list of attributes. The uuid changes if the
    attribute if reset.

    *Arguments*
      names ([:class:`string`])
        list of attribute names

    *Returns*
      the uuid
    """
    if len(names) == 0:
      return self._uuid
    elif len(names) == 1:
      name = names[0]
      # lambda attribute
      if self._func_attributes.has_key(name):
        attr = self._func_attributes[name]
        if attr.keys == None: getattr(self, name)
        if attr.keys == ():
          return getattr(self, name)
        else:
          return self.uuid(*attr.keys)

      # no lambda attribute
      else:
        attr = getattr(self, name)

        # object attribute (e.g. Function)
        if hasattr(attr, "uuid"):
          return attr.uuid

        # primitive attribute
        else:
          return attr
    else:
      return map(lambda x: self.uuid(x), names)

  def wrapped_mesh_for(self, domain):
    """
    Creates a :class:`WrappedMesh` object for a certain domain. This can be
    used to crop certain state values like the magnetization to a region of
    interest.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        domain identifier (either string or id)

    *Returns*
      :class:`WrappedMesh`
        the wrapped mesh
    """
    if not self._wrapped_meshes.has_key(domain):
      self._wrapped_meshes[domain] = WrappedMesh.create(self.mesh, self.domain_ids(domain))

    return self._wrapped_meshes[domain]

  def volume(self, domain = 'all'):
    """
    Computes the volume of a certain domain.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        domain identifier (either string or id)

    *Returns*
      :class:`float`
        the volume of the region
    """
    if not self._volumes.has_key(domain):
      self._volumes[domain] = assemble(Constant(1.0)*self.dx(domain))

    return self._volumes[domain]

  @property
  def material(self):
    return self._material

  @material.setter
  def material(self, value):
    if value is None:
      self._material = CompositeMaterial(self, Material())
    elif isinstance(value, Material):
      self._material = CompositeMaterial(self, value)
    else:
      raise AttributeError("Type not supported.")

  def set_celldomains(self, celldomains):
    self.celldomains = {}
    for material in celldomains:
      ids = celldomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.celldomains[material] = ids

  def set_facetdomains(self, facetdomains):
    self.facetdomains = {}
    for material in facetdomains:
      ids = facetdomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.facetdomains[material] = ids

  def domain_ids(self, domain, domaintype = 'cell'):
    """
    Get the domain IDs for a named domain.

    *Arguments*
      domain (:class:`string`/ :class:`int`)
        name or ID of domain
      domaintype (:class:`string`)
        domain type, (cell, facet)

    *Returns*
      :class:`[int]`
        List of domain IDs
    """
    if isinstance(domain, int):
      return [domain]

    domains = {
        'cell':  self.celldomains,
        'facet': self.facetdomains
      }[domaintype]

    if domain == 'all':
      ids = tuple()
      for material in domains:
        ids = ids + domains[material]
      return tuple(set(ids))
    elif domain[0] == '!':
      ids = set(self.domain_ids('all', domaintype))
      for id in self.domain_ids(domain[1:], domaintype):
        ids.remove(id)
      return tuple(ids)
    else:
      try:
        return domains[domain]
      except KeyError:
        raise KeyError("Unknown domain '%s'." % domain)

  def dx(self, domain = "all", dx = None):
    """
    Convenience wrapper for integral-cell measure. If the mesh does not contain
    any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      dx (:class:`dolfin:Measure`)
        alternative measure

    *Returns*
      :class:`dolfin:Measure`
        the measure


        # Compute volume of magnetic domain
        assemble(Constant(1.0) * state.dx('magnetic'))

        # Compute volume of domain with ID 3
        assemble(Constant(1.0) * state.dx(3))
    """
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._dx

    domain_ids = self.domain_ids(domain)
    # XXX fall back to zero measure
    if len(domain_ids) == 0: domain_ids = (999999,)

    if dx == None: dx = self._dx

    return reduce(lambda x,y: x+y, map(lambda i: dx(i), domain_ids))
 
  def dP(self, domain = "all"):
    """
    Convenience wrapper for integral-point measure. If the mesh does not contain
    any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain

    *Returns*
      :class:`dolfin:Measure`
        the measure
    """
    if not self.mesh_has_domains(): return Measure('dP', self.mesh)

    if not self._dP.has_key(domain):
      v = TestFunction(self.FunctionSpace())
      values = assemble(v*self.dx(domain)).array()
      # TODO improve this?
      markers = ((np.sign(np.ceil(values) - 0.5) + 1.0) / 2.0).astype(np.uint64)

      vertex_domains = MeshFunction('size_t', self.mesh, 0)
      vertex_domains.array()[:] = markers

      self._dP[domain] = Measure('dP', self.mesh)[vertex_domains](1)

    return self._dP[domain]

  def ds(self, domain = "all", ds = None, intersect = None):
    """
    Convenience wrapper for integral-facet measure. If the mesh does not
    contain any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      ds (:class:`dolfin:Measure`)
        alternative measure
      intersect (:class:`string` / :class:`int`)
        name or ID of anothe domain to intersect with

    *Returns*
      :class:`dolfin:Measure`
        the measure
    """
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._ds

    domain_ids = self.domain_ids(domain, 'facet')
    if intersect is not None:
      domain_ids = list(set(self.domain_ids(intersect, 'facet')).intersection(domain_ids))
    # XXX fall back to zero measure
    if len(domain_ids) == 0: domain_ids = (999999,)

    if ds == None: ds = self._ds

    measure = ds(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += ds(domain_id)

    return reduce(lambda x,y: x+y, map(lambda i: ds(i), domain_ids))

  def dS(self, domain = "all", dS = None):
    """
    Convenience wrapper for integral-interior-facet measure. If the mesh does
    not contain any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      dS (:class:`dolfin:Measure`)
        alternative measure

    *Returns*
      :class:`dolfin:Measure`
        the measure
    """
    if dS == None:
      return self.ds(domain, self._dS)
    else:
      return self.ds(domain, dS)

  def mesh_has_domains(self):
    """
    Returns True if mesh contains cell-domain data.

    *Returns*
      :class:`bool`
        True if mesh contains cell-domain data
    """
    return self.mesh.domains().num_marked(3) != 0

  def interpolate(self, expressions):
    """
    Interpolates a collection of expressions, each defined for a specific domain,
    on a suitable function space. Also works for a single expression.

    *Arguments*
      expressions (:class:`dict`)
        Expressions to be interpolated.

    *Returns*
      :class:`dolfin.Function`
        Interpolated function

    *Example*
      .. code-block:: python

        f1 = state.interpolate({
          'magnetic':  Constant((1.0, 0.0, 0.0)),
          '!magnetic': Constant((0.0, 1.0, 0.0))
        })

        f2 = state.interpolate(Constant(1.0))
    """
    # single expression
    if isinstance(expressions, GenericFunction):
      if isinstance(expressions, Function):
        # TODO check if function spaces match
        return expressions
      else:
        return interpolate(
          expressions,
          self.FunctionSpace(rank = expressions.rank())
        )
    # multiple expressions (dict)
    else:
      result = Function(self.FunctionSpace(rank = expressions.itervalues().next().rank()))
      result.vector().zero()
      for domain in expressions:
        wmesh = self.wrapped_mesh_for(domain)
        expression = expressions[domain]
        f = interpolate(expression, self.FunctionSpace(wmesh, expression.rank()))
        wmesh.expand(f, result)
      return result

  def step(self, integrators, dt):
    """
    Calls the step method on every integrator and increases :code:`t`.

    *Arguments*
      integrators (:class:`list` or :class:`Integrator`)
        Integrator on which the step method is called.
        Can be either a list of integrators or a single integrator.
    """
    if not isinstance(integrators, collections.Iterable):
      integrators = [integrators]

    for integrator in integrators:
      integrator.step(self, dt)

    self.t += dt

  def VectorFunctionSpace(self, mesh = None):
    """
    Returns the vector-function space for a mesh.

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        the mesh, defaults to mesh of the state if set to :code:`None`

    *Returns*
      :class:`dolfin.FunctionSpace`
        the function space
    """
    if mesh == None: return self._VV
    element = self._VS.ufl_element()
    return VectorFunctionSpace(mesh, element.family(), element.degree())

  def FunctionSpace(self, mesh = None, rank = 0):
    """
    Returns a function space for a mesh.

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        the mesh, defaults to mesh of the state if set to :code:`None`
      rank (:class:`int`)
        the rank of the function space (0 for scalar space, 1 for vector space)

    *Returns*
      :class:`dolfin.FunctionSpace`
        the function space
    """
    if rank == 0:
      if mesh == None: return self._VS
      element = self._VS.ufl_element()
      return FunctionSpace(mesh, element.family(), element.degree())
    elif rank == 1:
      return self.VectorFunctionSpace(mesh)
    else:
      raise Exception("Rank > 1 not supported.")

  def M_inv_diag(self, domain = "all"):
    """
    Returns the inverse lumped mass matrix for the vector function space.
    The result ist cached.

    .. note:: This method requires the PETSc Backend to be enabled.

    *Returns*
      :class:`dolfin.Matrix`
        the matrix
    """
    if not self._M_inv_diag.has_key(domain):
      v = TestFunction(self.VectorFunctionSpace())
      u = TrialFunction(self.VectorFunctionSpace())

      mass_form = inner(v, u) * self.dx(domain)
      mass_action_form = action(mass_form, Constant((1.0, 1.0, 1.0)))
      diag = assemble(mass_action_form)
      as_backend_type(diag).vec().reciprocal()

      result = assemble(inner(v, u) * dP)
      result.zero()
      result.set_diagonal(diag)
      self._M_inv_diag[domain] = result

    return self._M_inv_diag[domain]

  @property
  def full(self):
    return self

  def expand(self, func):
    return func

  def cut(self, func):
    return func

  def mask(self, domain):
    # TODO also check if domain spans the whole mesh
    if self.mesh_has_domains():
      return MaskedState(self, domain)
    else:
      return self

class MaskedMaterial(object):
  def __init__(self, material, mesh):
    self._material = material
    self._mesh     = mesh

  def __getattr__(self, name):
    value = getattr(self._material, name)
    if isinstance(value, Function):
      return self._mesh.cut(value)
    else:
      return value

  def __setitem__(self, name, value):
    raise AttributeError("MaskedState does not support material setters")


class MaskedState(State):
  def __init__(self, state, domain):
    """
    TODO

    *Arguments*
    """
    self._init   = True
    self._state  = state
    self._domain = domain

    mesh = state.wrapped_mesh_for(domain)

    super(MaskedState, self).__init__(mesh,
        celldomains  = state.celldomains,
        facetdomains = state.facetdomains,
        scale        = state.scale
    )
    del self.t
    self._attributes = {}

    self._init = False

  def __setattr__(self, name, value):
    if name in ('_init', 'material') or self._init:
      super(MaskedState, self).__setattr__(name, value)
    elif isinstance(value, Function):
      # XXX
      #setattr(self._state, name, self.mesh.expand(value, getattr(self._state, name)))
      f_full = getattr(self.full, name)
      self.mesh.expand(value, f_full)
      f_full.update_uuid()
    else:
      setattr(self._state, name, value)

  def __getattr__(self, name):
    value = getattr(self._state, name)
    if isinstance(value, GenericFunction):
      if self._attributes.has_key(name):
        attr = self._attributes[name]
        if not attr.uuid == value.uuid:
          self._attributes[name].assign(self.mesh.cut(value))
          self._attributes[name].uuid = self._state.uuid(name)
      else:
        result = self.mesh.cut(value)
        self._attributes[name] = self._decorate_attr(name, result)

      return self._attributes[name]
    else:
      return value

  def expand(self, func):
    if isinstance(func, Function):
      with Timer("expand mesh"):
        return self.mesh.expand(func)
    else:
      return func

  def cut(self, func):
    if isinstance(func, Function):
      with Timer("cut mesh"):
        return self.mesh.cut(func)
    else:
      return func

  @property
  def material(self):
    return MaskedMaterial(self._state.material, self.mesh)

  @material.setter
  def material(self, value):
    if self._init == False:
      raise AttributeError("MaskedState does not support material setters.")

  @property
  def full(self):
    return self._state.full
