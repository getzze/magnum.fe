# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-16

from __future__ import print_function, absolute_import 

from dolfin import *
try:
  from bempp.lib import *
  _found_bempp = True
except Exception as e:
  # TODO log warning
  print("Could not load BEM++ : {}".format(e))
  _found_bempp = False

import numpy as np

from magnumfe.llg_terms import LLGTerm
from magnumfe.common import Timer, WrappedMesh, Constants

__all__ = ["FredkinKoehler"]

# TODO handle differnet regions
class FredkinKoehler(object):
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses the FEM-BEM coupling as proposed by Fredkin and Koehler.
  """

  def __init__(self, domain_name, rhs_form):
    """
    *Arguments*
        domain_name (:class:`string`)
            Domain name of the region to solve.
        rhs_form (:class:`lambda`)
            Lambda that returns the RHS part of the weak form.
    """

    #if not _found_bempp: TODO log warning
    self.domain_name = domain_name
    self.rhs_form    = rhs_form

  def calculate_u1(self, rhs_coeffs, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u1'):
      cache = self._assemble_cache_u1 = Cache()

      # form setup
      mesh = V.mesh()
      u = TrialFunction(V)
      v = TestFunction(V)
      n = FacetNormal(mesh)

      # setup RHS coefficients
      cache.rhs_coeffs = []
      for coeff in rhs_coeffs:
        result = None
        if isinstance(coeff, Constant):
          # TODO there has be to be a more elegant way
          if coeff.rank() == 0: result = Constant(0.0)
          if coeff.rank() == 1: result = Constant((0.0, 0.0, 0.0))
        elif isinstance(coeff, Function):
          result = Function(coeff.function_space())

        if result == None: raise "Coefficient type not supported"
        cache.rhs_coeffs.append(result)

      a = inner(grad(u), grad(v)) * dx
      L = self.rhs_form(cache.rhs_coeffs, v, n)

      cache.w = Function(V)

      null_vec = Vector(cache.w.vector())
      V.dofmap().set(null_vec, 1.0)
      null_vec *= 1.0/null_vec.norm("l2")
      cache.null_space = VectorSpaceBasis([null_vec])

      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L)
      cache.assembler.assemble(cache.A)

      cache.solver = KrylovSolver(cache.A, "cg")
      cache.solver.set_nullspace(cache.null_space)

    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u1

    # assign RHS coefficients
    for source, target in zip(rhs_coeffs, cache.rhs_coeffs):
      target.assign(source)

    cache.assembler.assemble(cache.b)
    cache.null_space.orthogonalize(cache.b)
    cache.solver.solve(cache.w.vector(), cache.b)

    return cache.w

  def calculate_u2_bc(self, u1, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2_bc'):
      cache = self._assemble_cache_u2_bc = Cache()

      cache.boundary_mesh = BoundaryMesh(u1.function_space().mesh(), "exterior", False)
      cache.bm_coords     = cache.boundary_mesh.coordinates()
      cache.bm_cells      = cache.boundary_mesh.cells()
      cache.bm_nodes      = cache.boundary_mesh.entity_map(0).array().astype(np.int64)
      cache.mapping       = np.array(vertex_to_dof_map(u1.function_space())).take(cache.bm_nodes)

      # import mesh from Fenics
      grid = createGridFactory().createGridFromConnectivityArrays('triangular', cache.bm_coords.transpose(), cache.bm_cells.transpose())

      # set quadrature strategies
      accuracyOptions = createAccuracyOptions()
      accuracyOptions.doubleRegular.setRelativeQuadratureOrder(5)
      accuracyOptions.doubleSingular.setRelativeQuadratureOrder(5)
      accuracyOptions.singleRegular.setRelativeQuadratureOrder(5)
      quadStrategy = createNumericalQuadratureStrategy("float64", "float64", accuracyOptions)

      # Create assembly context and initialize spaces 
      assemblyOptions = createAssemblyOptions()
      assemblyOptions.switchToAcaMode(createAcaOptions()) # needs AHMED library
      cache.context = createContext(quadStrategy, assemblyOptions)
      cache.pwiseLinears = createPiecewiseLinearContinuousScalarSpace(cache.context, grid)

      # Construct elementary operators
      cache.dlpOp = createLaplace3dDoubleLayerBoundaryOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears)
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2_bc

    # Construct the grid function representing the (input) Dirichlet data
    u1_BEM = createGridFunction(cache.context, cache.pwiseLinears, cache.pwiseLinears, coefficients=u1.vector()[cache.mapping])
    u2_BEM = cache.dlpOp * u1_BEM

    # set u2 dirichlet boundary conditions
    V = u1.function_space()

    coef = u2_BEM.coefficients()
    u2_BC = Function(V)
    u2_BC.vector()[cache.mapping] = coef

    return DirichletBC(V, u2_BC, DomainBoundary())

  def calculate_u2(self, bc, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2'):
      cache = self._assemble_cache_u2 = Cache()
      u = TrialFunction(V)
      v = TestFunction(V)

      # define u2 dirichlet-problem 
      a = inner(grad(u), grad(v)) * dx
      L = Constant(0.0) * v * dx

      cache.A = assemble(a)
      cache.b = assemble(L)

      cache.u2 = Function(V)
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2

    bc.apply(cache.A, cache.b)
    solver = KrylovSolver(cache.A, "cg", "amg")
    solver.solve(cache.u2.vector(), cache.b)

    return cache.u2

  def calculate(self, state, *args):
    """
    Solve the open boundary problem for a given state.

    *Arguments*
        state (:class:`State`)
            The simulation state
        *args
            Additional coefficients used in the RHS form.
    """

    # extract magnetic part of mesh if necessary
    class Cache(): pass
    if not hasattr(self, '_assemble_cache'):
      cache = self._assemble_cache = Cache()

      if state.mesh_has_domains():
        cache.mesh = WrappedMesh.create(state.mesh, state.domain_ids(self.domain_name))
        cache.V = state.FunctionSpace(cache.mesh)
      else:
        cache.V = state.FunctionSpace()
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache

    # prepare RHS coefficients
    rhs_coeffs = []
    for coeff in args:
      if isinstance(coeff, Function):
        if state.mesh_has_domains():
          rhs_coeffs.append(cache.mesh.cut(coeff))
        else:
          rhs_coeffs.append(coeff)
      else:
        rhs_coeffs.append(coeff)

    with Timer("u1 FEM"): u1 = self.calculate_u1(rhs_coeffs, cache.V)
    with Timer("u2 BEM"): bc = self.calculate_u2_bc(u1, cache.V)
    with Timer("u2 FEM"): u2 = self.calculate_u2(bc, cache.V)

    result = Function(cache.V, - 0.5 * u1.vector() - u2.vector())

    if state.mesh_has_domains():
      return cache.mesh.expand(result)
    else:
      return result
